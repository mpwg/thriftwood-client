---
description: "Copilot instructions generated from an analysis of the Thriftwood iOS Swift code in this repository. These guidelines are strictly derived from existing code patterns and conservative, explicit compatibility notes. Do not assume anything not listed here."
---

# GitHub Copilot Instructions for thriftwood-client (iOS Swift)

Overview

- These instructions are generated by scanning the repository Swift sources under `ThriftwoodNative/Core` and `Features`.
- Only follow patterns and versions that are explicitly visible in the code. Do not introduce newer language features unless you verify they are supported in the project configuration.

Priority guidelines

1. Version compatibility: prefer language features compatible with Swift 6.0+ (async/await, @MainActor are used in the code). If you need to use features beyond Swift 6.0, verify project settings first.
2. Follow existing architectural boundaries: Core services, Repository layer, ViewModel layer, and Views are distinct and should not be mixed.
3. Prefer protocols for dependencies: services (NetworkService, StorageService) and repositories expose protocols in `Core/SharedTypes.swift` and are resolved via `DIContainer`.
4. Keep generated code consistent with existing naming, error handling, and Codable usage.

What to scan first

- `ThriftwoodNative/Core/SharedTypes.swift` — canonical protocols, models, and shared errors.
- `ThriftwoodNative/Core/DependencyInjection/DIContainer.swift` — DI registration patterns (register vs registerSingleton, using ObjectIdentifier keys).
- `ThriftwoodNative/Core/Networking/NetworkService.swift` and `SharedTypes.swift` network code — request signatures, error types, JSON coding patterns.
- `ThriftwoodNative/Core/Architecture/ViewModel/BaseViewModel.swift` — ViewModel base class patterns, @MainActor usage, published properties and helper methods like `withLoading`.

Coding conventions and style (observed patterns)

- Use Swift Protocols to define service contracts (e.g., `NetworkService`, `StorageService`, `DashboardRepository`, `SettingsRepository`).
- Use `final` for concrete implementations (e.g., `NetworkServiceImpl`, `StorageServiceImpl`).
- Prefer `@MainActor` on ViewModel protocols/classes and on `DIContainer` where UI-bound state is managed.
- Use `async throws` for asynchronous operations and propagate errors using Swift's error model.
- Use `Codable` for models and `JSONEncoder`/`JSONDecoder` for storage/network serialization.
- Use `@unchecked Sendable` for service implementations that are safe to use across concurrency domains but not explicitly audited.
- Use `UserDefaults` for small persistent data via `StorageServiceImpl` (already implemented).

Dependency injection patterns

- The code uses a small hand-rolled DI container `DIContainer`:
  - `register<T>(_ type: T.Type, factory: @escaping () -> T)` for non-singletons
  - `registerSingleton<T>(_ type: T.Type, factory: @escaping () -> T)` for singletons
  - `resolve<T>(_ type: T.Type) -> T` that fatals if missing
  - ViewModels are expected to be resolved or created via `makeViewModel` convenience

When adding or modifying dependencies:

- Register new services in `DIContainer.registerDependencies()` consistent with existing services.
- If a dependency must be a singleton, use `registerSingleton(...)` and return a concrete instance.
- Resolve dependencies by protocol type, not concrete type, where possible (e.g., `NetworkService.self`).

Concurrency and threading

- Use `async/await` for asynchronous methods and mark UI-facing types with `@MainActor`.
- Use Combine sparingly where present (some files import Combine); prefer structured concurrency for new async flows unless matching an existing Combine pattern.
- Use `@unchecked Sendable` on service implementations when the codebase does so for URLSession-backed or UserDefaults-backed services.

Error handling

- Reuse existing error enums (`NetworkError`, `StorageError`, `ViewModelError`) where appropriate.
- Provide localized descriptions by conforming to `LocalizedError` or mapping to `ViewModelError.generic` when appropriate.
- Propagate errors via `throws` and set `error` on `BaseViewModel` via the `withLoading` helper so UI state updates consistently.

Models and serialization

- Models are `Codable`. Maintain snake-case / camelCase where present (current models use camelCase and String raw values for enums).
- Use `JSONEncoder`/`JSONDecoder` default settings unless there is an existing custom configuration in the codebase.

ViewModel conventions

- All ViewModels conform to `ViewModel` (protocol in `BaseViewModel.swift`) and often subclass `BaseViewModel`.
- Expose `@Published` properties for view state (`isLoading`, `error`, and other published properties).
- Use `withLoading` to wrap async calls to ensure consistent loading/error handling.

Networking

- Use `NetworkService.request<T: Codable>(_ endpoint: APIEndpoint) async throws -> T` signature.
- Build requests by appending `endpoint.path` to the base URL and setting `endpoint.method`, `endpoint.headers`, and `endpoint.body`.
- Expect `Content-Type: application/json` and use `JSONDecoder` for responses.

Storage

- Use `StorageService` protocol with `save`, `load`, and `delete` async methods.
- `StorageServiceImpl` persists encoded data into `UserDefaults`.

Tests and examples

- There are no unit tests in the scanned Swift files. When adding tests, follow these conventions:
  - Use XCTest and structure tests to mirror the repository and service interfaces (e.g., `SettingsRepositoryTests` testing `SettingsRepositoryImpl`).
  - Use dependency injection to inject mocks for `NetworkService`/`StorageService`.

Files to update when making changes

- `ThriftwoodNative/Core/DependencyInjection/DIContainer.swift` — update registrations
- `ThriftwoodNative/Core/SharedTypes.swift` — shared protocols and models
- `ThriftwoodNative/Core/Architecture/ViewModel/BaseViewModel.swift` — viewmodel helpers

Conservative compatibility notes (explicit)

- The codebase uses `async/await`, `@MainActor`, and `@unchecked Sendable`. These features require Swift 6.0+ and a deployment target that supports concurrency (iOS 18+). If you need to use features newer than Swift 6.0, first confirm project settings in the Xcode project.
- Do not change `NetworkService` or `StorageService` method signatures without updating all callers and DI registrations.

Do not assume

- Do not assume a specific Swift compiler or iOS deployment target unless you verify it in the Xcode project.
- Do not replace the DI approach with a third-party DI framework unless a repository-level decision is made and all registrations are migrated.

Examples (copy these patterns)

- Protocol + Impl pattern

  protocol SettingsRepository {
  func loadSettings() async throws -> AppSettings
  func saveSettings(\_ settings: AppSettings) async throws
  }

  final class SettingsRepositoryImpl: SettingsRepository {
  // ... initializer injected StorageService ...
  }

- Using withLoading in ViewModel

  await withLoading {
  let settings = try await repository.loadSettings()
  // update published properties
  }

Placement and usage

- Save this file as `.github/copilot/copilot-instructions.md` in the repository root. Copilot should consult this file before generating Swift code and follow these repository-specific patterns.

Acknowledgement

- This file was generated automatically by scanning the repository Swift sources. It intentionally avoids prescriptive recommendations that are not evident in the codebase. Before making large cross-cutting changes (tooling, Swift language level, DI strategy), verify project configuration files and discuss with repository owners.
