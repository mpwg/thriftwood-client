//
// MediaInfoResource.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

public struct MediaInfoResource: Sendable, Codable, ParameterConvertible, Hashable {

    public var id: Int?
    public var audioBitrate: Int64?
    public var audioChannels: Double?
    public var audioCodec: String?
    public var audioLanguages: String?
    public var audioStreamCount: Int?
    public var videoBitDepth: Int?
    public var videoBitrate: Int64?
    public var videoCodec: String?
    public var videoFps: Double?
    public var videoDynamicRange: String?
    public var videoDynamicRangeType: String?
    public var resolution: String?
    public var runTime: String?
    public var scanType: String?
    public var subtitles: String?

    public init(id: Int? = nil, audioBitrate: Int64? = nil, audioChannels: Double? = nil, audioCodec: String? = nil, audioLanguages: String? = nil, audioStreamCount: Int? = nil, videoBitDepth: Int? = nil, videoBitrate: Int64? = nil, videoCodec: String? = nil, videoFps: Double? = nil, videoDynamicRange: String? = nil, videoDynamicRangeType: String? = nil, resolution: String? = nil, runTime: String? = nil, scanType: String? = nil, subtitles: String? = nil) {
        self.id = id
        self.audioBitrate = audioBitrate
        self.audioChannels = audioChannels
        self.audioCodec = audioCodec
        self.audioLanguages = audioLanguages
        self.audioStreamCount = audioStreamCount
        self.videoBitDepth = videoBitDepth
        self.videoBitrate = videoBitrate
        self.videoCodec = videoCodec
        self.videoFps = videoFps
        self.videoDynamicRange = videoDynamicRange
        self.videoDynamicRangeType = videoDynamicRangeType
        self.resolution = resolution
        self.runTime = runTime
        self.scanType = scanType
        self.subtitles = subtitles
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case id
        case audioBitrate
        case audioChannels
        case audioCodec
        case audioLanguages
        case audioStreamCount
        case videoBitDepth
        case videoBitrate
        case videoCodec
        case videoFps
        case videoDynamicRange
        case videoDynamicRangeType
        case resolution
        case runTime
        case scanType
        case subtitles
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(id, forKey: .id)
        try container.encodeIfPresent(audioBitrate, forKey: .audioBitrate)
        try container.encodeIfPresent(audioChannels, forKey: .audioChannels)
        try container.encodeIfPresent(audioCodec, forKey: .audioCodec)
        try container.encodeIfPresent(audioLanguages, forKey: .audioLanguages)
        try container.encodeIfPresent(audioStreamCount, forKey: .audioStreamCount)
        try container.encodeIfPresent(videoBitDepth, forKey: .videoBitDepth)
        try container.encodeIfPresent(videoBitrate, forKey: .videoBitrate)
        try container.encodeIfPresent(videoCodec, forKey: .videoCodec)
        try container.encodeIfPresent(videoFps, forKey: .videoFps)
        try container.encodeIfPresent(videoDynamicRange, forKey: .videoDynamicRange)
        try container.encodeIfPresent(videoDynamicRangeType, forKey: .videoDynamicRangeType)
        try container.encodeIfPresent(resolution, forKey: .resolution)
        try container.encodeIfPresent(runTime, forKey: .runTime)
        try container.encodeIfPresent(scanType, forKey: .scanType)
        try container.encodeIfPresent(subtitles, forKey: .subtitles)
    }
}


@available(iOS 13, tvOS 13, watchOS 6, macOS 10.15, *)
extension MediaInfoResource: Identifiable {}
