//
// ManualImportResource.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

public struct ManualImportResource: Sendable, Codable, ParameterConvertible, Hashable {

    public var id: Int?
    public var path: String?
    public var relativePath: String?
    public var folderName: String?
    public var name: String?
    public var size: Int64?
    public var movie: MovieResource?
    public var movieFileId: Int?
    public var releaseGroup: String?
    public var quality: QualityModel?
    public var languages: [Language]?
    public var qualityWeight: Int?
    public var downloadId: String?
    public var customFormats: [CustomFormatResource]?
    public var customFormatScore: Int?
    public var indexerFlags: Int?
    public var rejections: [ImportRejectionResource]?

    public init(id: Int? = nil, path: String? = nil, relativePath: String? = nil, folderName: String? = nil, name: String? = nil, size: Int64? = nil, movie: MovieResource? = nil, movieFileId: Int? = nil, releaseGroup: String? = nil, quality: QualityModel? = nil, languages: [Language]? = nil, qualityWeight: Int? = nil, downloadId: String? = nil, customFormats: [CustomFormatResource]? = nil, customFormatScore: Int? = nil, indexerFlags: Int? = nil, rejections: [ImportRejectionResource]? = nil) {
        self.id = id
        self.path = path
        self.relativePath = relativePath
        self.folderName = folderName
        self.name = name
        self.size = size
        self.movie = movie
        self.movieFileId = movieFileId
        self.releaseGroup = releaseGroup
        self.quality = quality
        self.languages = languages
        self.qualityWeight = qualityWeight
        self.downloadId = downloadId
        self.customFormats = customFormats
        self.customFormatScore = customFormatScore
        self.indexerFlags = indexerFlags
        self.rejections = rejections
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case id
        case path
        case relativePath
        case folderName
        case name
        case size
        case movie
        case movieFileId
        case releaseGroup
        case quality
        case languages
        case qualityWeight
        case downloadId
        case customFormats
        case customFormatScore
        case indexerFlags
        case rejections
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(id, forKey: .id)
        try container.encodeIfPresent(path, forKey: .path)
        try container.encodeIfPresent(relativePath, forKey: .relativePath)
        try container.encodeIfPresent(folderName, forKey: .folderName)
        try container.encodeIfPresent(name, forKey: .name)
        try container.encodeIfPresent(size, forKey: .size)
        try container.encodeIfPresent(movie, forKey: .movie)
        try container.encodeIfPresent(movieFileId, forKey: .movieFileId)
        try container.encodeIfPresent(releaseGroup, forKey: .releaseGroup)
        try container.encodeIfPresent(quality, forKey: .quality)
        try container.encodeIfPresent(languages, forKey: .languages)
        try container.encodeIfPresent(qualityWeight, forKey: .qualityWeight)
        try container.encodeIfPresent(downloadId, forKey: .downloadId)
        try container.encodeIfPresent(customFormats, forKey: .customFormats)
        try container.encodeIfPresent(customFormatScore, forKey: .customFormatScore)
        try container.encodeIfPresent(indexerFlags, forKey: .indexerFlags)
        try container.encodeIfPresent(rejections, forKey: .rejections)
    }
}


@available(iOS 13, tvOS 13, watchOS 6, macOS 10.15, *)
extension ManualImportResource: Identifiable {}
