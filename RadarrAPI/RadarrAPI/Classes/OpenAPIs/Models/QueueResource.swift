//
// QueueResource.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

public struct QueueResource: Sendable, Codable, ParameterConvertible, Hashable {

    public var id: Int?
    public var movieId: Int?
    public var movie: MovieResource?
    public var languages: [Language]?
    public var quality: QualityModel?
    public var customFormats: [CustomFormatResource]?
    public var customFormatScore: Int?
    public var size: Double?
    public var title: String?
    public var estimatedCompletionTime: Date?
    public var added: Date?
    public var status: QueueStatus?
    public var trackedDownloadStatus: TrackedDownloadStatus?
    public var trackedDownloadState: TrackedDownloadState?
    public var statusMessages: [TrackedDownloadStatusMessage]?
    public var errorMessage: String?
    public var downloadId: String?
    public var _protocol: DownloadProtocol?
    public var downloadClient: String?
    public var downloadClientHasPostImportCategory: Bool?
    public var indexer: String?
    public var outputPath: String?
    @available(*, deprecated, message: "This property is deprecated.")
    public var sizeleft: Double?
    @available(*, deprecated, message: "This property is deprecated.")
    public var timeleft: String?

    public init(id: Int? = nil, movieId: Int? = nil, movie: MovieResource? = nil, languages: [Language]? = nil, quality: QualityModel? = nil, customFormats: [CustomFormatResource]? = nil, customFormatScore: Int? = nil, size: Double? = nil, title: String? = nil, estimatedCompletionTime: Date? = nil, added: Date? = nil, status: QueueStatus? = nil, trackedDownloadStatus: TrackedDownloadStatus? = nil, trackedDownloadState: TrackedDownloadState? = nil, statusMessages: [TrackedDownloadStatusMessage]? = nil, errorMessage: String? = nil, downloadId: String? = nil, _protocol: DownloadProtocol? = nil, downloadClient: String? = nil, downloadClientHasPostImportCategory: Bool? = nil, indexer: String? = nil, outputPath: String? = nil, sizeleft: Double? = nil, timeleft: String? = nil) {
        self.id = id
        self.movieId = movieId
        self.movie = movie
        self.languages = languages
        self.quality = quality
        self.customFormats = customFormats
        self.customFormatScore = customFormatScore
        self.size = size
        self.title = title
        self.estimatedCompletionTime = estimatedCompletionTime
        self.added = added
        self.status = status
        self.trackedDownloadStatus = trackedDownloadStatus
        self.trackedDownloadState = trackedDownloadState
        self.statusMessages = statusMessages
        self.errorMessage = errorMessage
        self.downloadId = downloadId
        self._protocol = _protocol
        self.downloadClient = downloadClient
        self.downloadClientHasPostImportCategory = downloadClientHasPostImportCategory
        self.indexer = indexer
        self.outputPath = outputPath
        self.sizeleft = sizeleft
        self.timeleft = timeleft
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case id
        case movieId
        case movie
        case languages
        case quality
        case customFormats
        case customFormatScore
        case size
        case title
        case estimatedCompletionTime
        case added
        case status
        case trackedDownloadStatus
        case trackedDownloadState
        case statusMessages
        case errorMessage
        case downloadId
        case _protocol = "protocol"
        case downloadClient
        case downloadClientHasPostImportCategory
        case indexer
        case outputPath
        case sizeleft
        case timeleft
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(id, forKey: .id)
        try container.encodeIfPresent(movieId, forKey: .movieId)
        try container.encodeIfPresent(movie, forKey: .movie)
        try container.encodeIfPresent(languages, forKey: .languages)
        try container.encodeIfPresent(quality, forKey: .quality)
        try container.encodeIfPresent(customFormats, forKey: .customFormats)
        try container.encodeIfPresent(customFormatScore, forKey: .customFormatScore)
        try container.encodeIfPresent(size, forKey: .size)
        try container.encodeIfPresent(title, forKey: .title)
        try container.encodeIfPresent(estimatedCompletionTime, forKey: .estimatedCompletionTime)
        try container.encodeIfPresent(added, forKey: .added)
        try container.encodeIfPresent(status, forKey: .status)
        try container.encodeIfPresent(trackedDownloadStatus, forKey: .trackedDownloadStatus)
        try container.encodeIfPresent(trackedDownloadState, forKey: .trackedDownloadState)
        try container.encodeIfPresent(statusMessages, forKey: .statusMessages)
        try container.encodeIfPresent(errorMessage, forKey: .errorMessage)
        try container.encodeIfPresent(downloadId, forKey: .downloadId)
        try container.encodeIfPresent(_protocol, forKey: ._protocol)
        try container.encodeIfPresent(downloadClient, forKey: .downloadClient)
        try container.encodeIfPresent(downloadClientHasPostImportCategory, forKey: .downloadClientHasPostImportCategory)
        try container.encodeIfPresent(indexer, forKey: .indexer)
        try container.encodeIfPresent(outputPath, forKey: .outputPath)
        try container.encodeIfPresent(sizeleft, forKey: .sizeleft)
        try container.encodeIfPresent(timeleft, forKey: .timeleft)
    }
}


@available(iOS 13, tvOS 13, watchOS 6, macOS 10.15, *)
extension QueueResource: Identifiable {}
