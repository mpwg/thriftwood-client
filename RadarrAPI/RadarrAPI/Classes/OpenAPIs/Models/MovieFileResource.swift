//
// MovieFileResource.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

public struct MovieFileResource: Sendable, Codable, ParameterConvertible, Hashable {

    public var id: Int?
    public var movieId: Int?
    public var relativePath: String?
    public var path: String?
    public var size: Int64?
    public var dateAdded: Date?
    public var sceneName: String?
    public var releaseGroup: String?
    public var edition: String?
    public var languages: [Language]?
    public var quality: QualityModel?
    public var customFormats: [CustomFormatResource]?
    public var customFormatScore: Int?
    public var indexerFlags: Int?
    public var mediaInfo: MediaInfoResource?
    public var originalFilePath: String?
    public var qualityCutoffNotMet: Bool?

    public init(id: Int? = nil, movieId: Int? = nil, relativePath: String? = nil, path: String? = nil, size: Int64? = nil, dateAdded: Date? = nil, sceneName: String? = nil, releaseGroup: String? = nil, edition: String? = nil, languages: [Language]? = nil, quality: QualityModel? = nil, customFormats: [CustomFormatResource]? = nil, customFormatScore: Int? = nil, indexerFlags: Int? = nil, mediaInfo: MediaInfoResource? = nil, originalFilePath: String? = nil, qualityCutoffNotMet: Bool? = nil) {
        self.id = id
        self.movieId = movieId
        self.relativePath = relativePath
        self.path = path
        self.size = size
        self.dateAdded = dateAdded
        self.sceneName = sceneName
        self.releaseGroup = releaseGroup
        self.edition = edition
        self.languages = languages
        self.quality = quality
        self.customFormats = customFormats
        self.customFormatScore = customFormatScore
        self.indexerFlags = indexerFlags
        self.mediaInfo = mediaInfo
        self.originalFilePath = originalFilePath
        self.qualityCutoffNotMet = qualityCutoffNotMet
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case id
        case movieId
        case relativePath
        case path
        case size
        case dateAdded
        case sceneName
        case releaseGroup
        case edition
        case languages
        case quality
        case customFormats
        case customFormatScore
        case indexerFlags
        case mediaInfo
        case originalFilePath
        case qualityCutoffNotMet
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(id, forKey: .id)
        try container.encodeIfPresent(movieId, forKey: .movieId)
        try container.encodeIfPresent(relativePath, forKey: .relativePath)
        try container.encodeIfPresent(path, forKey: .path)
        try container.encodeIfPresent(size, forKey: .size)
        try container.encodeIfPresent(dateAdded, forKey: .dateAdded)
        try container.encodeIfPresent(sceneName, forKey: .sceneName)
        try container.encodeIfPresent(releaseGroup, forKey: .releaseGroup)
        try container.encodeIfPresent(edition, forKey: .edition)
        try container.encodeIfPresent(languages, forKey: .languages)
        try container.encodeIfPresent(quality, forKey: .quality)
        try container.encodeIfPresent(customFormats, forKey: .customFormats)
        try container.encodeIfPresent(customFormatScore, forKey: .customFormatScore)
        try container.encodeIfPresent(indexerFlags, forKey: .indexerFlags)
        try container.encodeIfPresent(mediaInfo, forKey: .mediaInfo)
        try container.encodeIfPresent(originalFilePath, forKey: .originalFilePath)
        try container.encodeIfPresent(qualityCutoffNotMet, forKey: .qualityCutoffNotMet)
    }
}


@available(iOS 13, tvOS 13, watchOS 6, macOS 10.15, *)
extension MovieFileResource: Identifiable {}
